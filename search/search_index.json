{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"SQLAlchemy Filterset <p> An easy way to filter, sort, paginate SQLAlchemy queries </p> <p> </p> <p> </p> <p>Documentation: https://sqlalchemy-filterset.github.io/sqlalchemy-filterset</p> <p>Source Code: https://github.com/sqlalchemy-filterset/sqlalchemy-filterset</p> <p>The library provides a convenient and organized way to filter your database records. By creating a <code>FilterSet</code> class, you can declaratively define the filters you want to apply to your <code>SQLAlchemy</code> queries. This library is particularly useful in web applications, as it allows users to easily search, filter, sort, and paginate data.</p> <p>The key features are:</p> <ul> <li> Declarative definition of filters.</li> <li> Keeping all of your filters in one place, making it easier to maintain and change them as needed.</li> <li> Constructing complex filtering conditions by combining multiple simple filters.</li> <li> Offer of a standard approach to writing database queries.</li> <li> Reduction of code duplication by reusing the same filters in multiple places in your code.</li> <li> Sync and Async support of modern SQLAlchemy.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><pre><code>pip install sqlalchemy-filterset\n</code></pre> Requirements: <code>Python 3.7+</code> <code>SQLAlchemy 2.0+</code></p>"},{"location":"#basic-filterset-and-filters-usage","title":"Basic FilterSet and Filters Usage","text":"<p>In this example we specify criteria for filtering the database records by simply setting the attributes of the <code>ProductFilterSet</code> class. This is more convenient and easier to understand than writing raw SQL queries, which can be more error-prone and difficult to maintain.</p>"},{"location":"#define-a-filterset","title":"Define a FilterSet","text":"<pre><code>from sqlalchemy_filterset import BaseFilterSet, Filter, RangeFilter, BooleanFilter\n\nfrom myapp.models import Product\n\n\nclass ProductFilterSet(BaseFilterSet):\n    id = Filter(Product.id)\n    price = RangeFilter(Product.price)\n    is_active = BooleanFilter(Product.is_active)\n</code></pre>"},{"location":"#define-a-filterschema","title":"Define a FilterSchema","text":"<pre><code>import uuid\nfrom pydantic import BaseModel\n\n\nclass ProductFilterSchema(BaseModel):\n    id: uuid.UUID | None\n    price: tuple[float, float] | None\n    is_active: bool | None\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code># Connect to the database\nengine = create_engine(\"postgresql://user:password@host/database\")\nBase.metadata.create_all(bind=engine)\nSessionLocal = sessionmaker(bind=engine)\nsession = SessionLocal()\n\n# Define sqlalchemy query\nquery = select(Product)\n\n# Define parameters for filtering\nfilter_params = ProductFilterSchema(price=(10, 100), is_active=True)\n\n# Create the filterset object\nfilter_set = ProductFilterSet(query)\n\n# Apply the filters to the query\nquery = filter_set.filter_query(filter_params.dict(exclude_unset=True))\n\n# Execute the query\nsession.execute(query).unique().scalars().all()\n</code></pre> <p>This example will generate the following query: <pre><code>select product.id, product.title, product.price, product.is_active\nfrom product\nwhere product.price &gt;= 10\nand product.price &lt;= 100\nand product.is_active = true;\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"#supported-by","title":"Supported by","text":""},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#github","title":"Github","text":""},{"location":"contributing/#issues","title":"Issues","text":"<p>Please create an issue to report a bug, request a feature or to simply ask a question.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Unless the pull request is a simple bugfix, please try to create an issue before starting on the implementation of your pull request. This ensures that the potential feature is in alignment with project goals. This also allows for feedback on the feature and potential help on where to start implementation wisely.</p>"},{"location":"contributing/#development","title":"Development","text":""},{"location":"contributing/#install-dependencies","title":"Install dependencies","text":"<pre><code>git clone git@github.com:sqlalchemy-filterse/sqlalchemy-filterset.git\ncd sqlalchemy-filterset\npoetry install\npre-commit install\n</code></pre>"},{"location":"contributing/#tests","title":"Tests","text":"<p>When adding additional features, please try to add tests that prove that your implementation works and is bug free.</p> <p>Tests require a postgres database.</p> <pre><code>pytest\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation was built using mkdocs-material. <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"contributing/#update-package-version","title":"Update package version","text":"<p>Run commitizen</p> <pre><code>poetry run cz bump --increment &lt;MAJOR|MINOR|PATCH&gt;\n</code></pre> <p>Push tag</p> <pre><code>git push &amp;&amp; git push origin &lt;tag_name&gt;\n</code></pre> <p>Publish to pypi <pre><code>POETRY_PYPI_TOKEN_PYPI=&lt;TOKEN&gt; poetry publish --build\n</code></pre></p> <p>Create release on Github</p>"},{"location":"filters/","title":"Filters","text":""},{"location":"filters/#overview","title":"Overview","text":"<p>The <code>Filter</code> class is used to filter records in a database. When we filter a query using a <code>FilterSet</code>, each filter sequentially takes a query object and a value argument. The query object is the base query that the <code>Filter</code> will modify with the specified filter, while the value argument is the value to use for filtering.</p>"},{"location":"filters/#base-filters","title":"Base filters","text":""},{"location":"filters/#filter","title":"Filter","text":"<p>The Filter filters records in a database by field and <code>lookup_expr</code>.</p> <ul> <li><code>field</code> - a field in a database model that the <code>Filter</code> will be applied to.</li> <li><code>lookup_expr</code> - a function that represents a lookup expression, such as an operator from the operator or <code>sqlalchemy.sql.operators</code> modules.</li> </ul> <p>For example: <pre><code>import operator as op\nfrom sqlalchemy.sql import operators as sa_op\nfrom sqlalchemy_filterset import FilterSet, Filter\n\n\nclass ProductFilterSet(FilterSet):\n    id = Filter(Product.id, lookup_expr=op.eq)\n    ids = Filter(Product.id, lookup_expr=sa_op.in_op)\n    name = Filter(Product.name, lookup_expr=sa_op.ilike_op)\n\n\n# filter records by id = 123\nfilter_params = {\"id\": 123}\nfilter_set = ProductFilterSet(session, select(Product))\nquery = filter_set.filter(filter_params)\n</code></pre></p> <p>Filter schema pattern:</p> dictpydantic <pre><code>value1 = 123\nvalue2 = \"some string\"\n\nfilter_params = {\"field1\": value1, \"field2\": value2}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    field1: int | None\n    field2: str | None\n\n\nvalue1 = 123\nvalue2 = \"some string\"\n\nfilter_params = ProductFilterSchema(field1=value1, field2=value2).dict(\n    exclude_unset=True\n)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"id\": 123}</code> <code>select * from product where id = 123;</code> <code>{\"ids\": [123, 345, 678]}</code> <code>select * from product where id in (123, 345, 678);</code> <code>{\"name\": \"some name\"}</code> <code>select * from product where name like 'some name';</code> <p>Here are some examples of sql conditions to be generated by various lookup expressions:</p> operator SQL expression operator.eq field = value operator.ne field != value operator.le field &lt;= value operator.lt field &lt; value operator.ge field &gt;= value operator.gt field &gt; value sqlalchemy.sql.operators.in_op field IN value sqlalchemy.sql.operators.is_ field IS value sqlalchemy.sql.operators.like_op field LIKE value sqlalchemy.sql.operators.ilike_op LOWER(field) LIKE value <p>All available operators can be found in the following modules:  <code>operator</code>, <code>sqlalchemy.sql.operators</code>, <code>sqlalchemy-filterset.operators</code></p>"},{"location":"filters/#rangefilter","title":"RangeFilter","text":"<p>The <code>RangeFilter</code> class is used to filter records in a database by a specific field within a specified range from start to end values.</p> <ul> <li><code>field</code> - a field in a database model that the RangeFilter will be applied to.</li> <li><code>left_lookup_expr/right_lookup_expr</code> - lookup expressions, such as operators from the operator module (<code>op.ge</code>, <code>op.gt</code>, <code>op.le</code>, <code>op.lt</code>).</li> <li><code>logic_expr</code> - logical operator, such as and_ or or_, that is used to produce a conjunction of the border expressions.</li> </ul> <p>For example: <pre><code>from sqlalchemy_filterset import FilterSet, RangeFilter\n\n\nclass ProductFilterSet(FilterSet):\n    price = RangeFilter(Product.price)\n    price_outer = RangeFilter(\n        Product.price,\n        left_lookup_expr=op.lt,\n        right_lookup_expr=op.gt,\n        logic_expr=sa_op.or_\n    )\n\n\n# filter records by the price field within a range of 1000 to 5000\nfilter_params = {\"price\": (1000, 5000)}\nfilter_set = ProductFilterSet(session, select(Product))\nquery = filter_set.filter(filter_params)\n</code></pre></p> <p>Filter schema pattern:</p> dictpydantic <pre><code>start_value1 = 1000\nend_value1 = 5000\n\nfilter_params = {\"field1\": (start_value1, end_value1)}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    price: tuple[int | None, int | None] | None\n\n\nstart_value1 = 1000\nend_value1 = 5000\n\nfilter_params = ProductFilterSchema(field1=(start_value1, end_value1)).dict(\n    exclude_unset=True\n)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"price\": (100, 1000)}</code> <code>select * from product where price &gt;= 100 and price &lt;= 1000;</code> <code>{\"price_outer\": (100, 1000)}</code> <code>select * from product where price &lt; 100 or price &gt; 1000;</code>"},{"location":"filters/#searchfilter","title":"SearchFilter","text":"<p><code>SearchFilter</code> allows you to search for a given string in specified fields.</p> <ul> <li><code>*fields</code> - one or several fields in a database model that the <code>SearchFilter</code> will be applied to.</li> <li><code>lookup_expr</code> - lookup expression, default - <code>lower(field) like '%{value}%'</code>.</li> <li><code>logic_expr</code> - logical operator, such as <code>and_</code> or <code>or_</code>, to produce a conjunction of search expressions.</li> </ul> <p>For example:</p> <pre><code>from sqlalchemy_filterset import FilterSet, SearchFilter\n\n\nclass ProductFilterSet(FilterSet):\n    search = SearchFilter(Product.name, Product.description)\n\n\n# filter records where name or description filds contain the text 'string'\nfilter_params = {\"search\": \"string\"}\nfilter_set = ProductFilterSet(session, select(Product))\nquery = filter_set.filter(filter_params)\n</code></pre> <p>Filter schema pattern:</p> dictpydantic <pre><code>value1 = \"string1\"\nvalue2 = \"string2\"\n\nfilter_params = {\"field1\": value1, \"field2\": value2}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    field1: str | None\n    field2: str | None\n\n\nvalue1 = \"string1\"\nvalue2 = \"string2\"\n\nfilter_params = ProductFilterSchema(field1=value1, field2=value2).dict(\n    exclude_unset=True\n)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"search\": \"string\"}</code> <code>select * from product</code><code>where lower(name) like '%string%' or lower(description) like '%string%';</code> <p>Warning</p> <ul> <li>Sql expression depends on the database engine. For more information, see the official documentation sqlalchemy.</li> </ul>"},{"location":"filters/#sorting","title":"Sorting","text":""},{"location":"filters/#orderingfilter","title":"OrderingFilter","text":"<p><code>OrderingFilter</code> allows you to specify the order in which the results of a query should be returned by adding an <code>order by</code> clause to the query based on specified fields.</p> <ul> <li><code>**fields</code> - one or several OrderingField that define possible sorting options.</li> </ul> <p><code>OrderingField</code></p> <ul> <li><code>field</code> - a field in a database model that the <code>OrderingFilter</code> will be applied to.</li> <li><code>nulls</code> - specifies whether null values should be sorted first or last.</li> </ul> <p>To apply the <code>OrderingFilter</code> to a query, pass it a sequence of field names and the direction of the ordering (ascending or descending by prefixing with \"-\").</p> <p>Here's an example:</p> <pre><code>from sqlalchemy_filterset import FilterSet, OrderingFilter, OrderingField\n\n\nclass ProductFilterSet(FilterSet):\n    ordering = OrderingFilter(\n        price=OrderingField(Product.price),\n        name=OrderingField(Product.name, nulls=NullsPosition.last),\n        id=OrderingField(Product.id)\n)\n\n\n# order records by name, descending price and by id\nfilter_params = {\"ordering\": [\"name\", \"-price\", \"id\"]}\nfilter_set = ProductFilterSet(session, select(Product))\nquery = filter_set.filter(filter_params)\n</code></pre> <p>Filter schema pattern:</p> dictpydantic <pre><code>ordering_field1 = \"field1\"\nordering_field2 = \"-field2\"\nordering_field3 = \"field3\"\n\nfilter_params = {\"ordering\": [ordering_field1, ordering_field2, ordering_field3]}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    ordering: list[str] | None\n\n\nordering_field1 = \"field1\"\nordering_field2 = \"-field2\"\nordering_field3 = \"field3\"\n\nfilter_params = ProductFilterSchema(\n    ordering=[ordering_field1, ordering_field2, ordering_field3]\n).dict(exclude_unset=True)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"ordering\": [\"price\"]}</code> <code>select * from product order by price;</code> <code>{\"ordering\": [\"-price\", \"id\"]}</code> <code>select * from product order by price desc, id;</code> <code>{\"ordering\": [\"name\", \"-price\", \"id\"]}</code> <code>select * from product</code><code>order by name nulls last, price desc, id;</code>"},{"location":"filters/#pagination","title":"Pagination","text":""},{"location":"filters/#limitoffsetfilter","title":"LimitOffsetFilter","text":"<p><code>LimitOffsetFilter</code> applies limit and offset pagination to a query. It is used to limit the number of results returned by the query and to specify a starting point (offset) in the results.</p> <p>This is useful for paginating results when displaying them to the user, as it allows you to retrieve a specific page of results rather than retrieving all results at once.</p> <p>To use <code>LimitOffsetFilter</code>, you pass it a query instance and a tuple containing the limit and offset values. Here is an example: <pre><code>from sqlalchemy_filterset import FilterSet, LimitOffsetFilter\n\n\nclass ProductFilterSet(FilterSet):\n    pagination = LimitOffsetFilter()\n\n\n# Out of the 100 records received in total,\n# only 10 records should be returned, starting from the 20th record.\nfilter_params = {\"pagination\": (10, 20)}\nfilter_set = ProductFilterSet(session, select(Product))\nquery = filter_set.filter(filter_params)\n</code></pre></p> <p>Filter schema pattern:</p> dictpydantic <pre><code>limit_value = 0\noffset_value = 10\n\nfilter_params = {\"pagination\": (limit_value, offset_value)}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    pagination: tuple[int, int] | None\n\nlimit_value = 0\noffset_value = 10\n\nfilter_params = ProductFilterSchema(\n    pagination=(limit_value, offset_value)\n).dict(exclude_unset=True)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"pagination\": (10, 0)}</code> <code>select * from product limit 10 offset 0;</code> <code>{\"pagination\": (10, 10)}</code> <code>select * from product limit 10 offset 10;</code> <p>LimitOffsetFilter and Joined Tables: Getting Accurate Pagination Results</p> <ul> <li> <p>When using this filter with joined tables, be aware that the join may modify the resulting set of records, which can affect the accuracy of pagination. This may include issues such as duplicate records or excluded records. It is important to take this into consideration and ensure that the join is properly set up to avoid these issues when using the <code>LimitOffsetFilter</code>.</p> </li> <li> <p>If we use the query: <pre><code>select users.*, roles.*\nfrom users\nleft join user_roles on users.id = user_roles.user_id\nleft join roles on user_roles.role_id = roles.id;\n</code></pre> and apply <code>LimitOffsetFilter</code>, we may end up with duplicate records. For example, if user with id 1 has 2 roles, we will get duplicate records of user 1 with different roles, which may affect the pagination results. We need to be attentive and use <code>SubqueryExistsStrategy</code> or modify sql query with group by or other methods to ensure that the join statement is set up correctly and it will not cause any issues with the pagination results.</p> </li> </ul>"},{"location":"filters/#custom-filters","title":"Custom filters","text":""},{"location":"filters/#infilternotinfilter","title":"InFilter/NotInFilter","text":"<p><code>InFilter</code> and <code>NotInFilter</code> are subclasses of the Filter class and allow you to filter a field based on a list using the <code>IN</code> and <code>NOT IN</code> SQL operators, respectively. Under the hood it is a <code>Filter</code> with special <code>in</code>/<code>not_in</code> lookup expressions.</p> <p>To use these filters, you can specify them in your <code>FilterSet</code> class like any other <code>Filter</code> and pass them a list of values to filter by. For example:</p> <pre><code>from sqlalchemy_filterset import FilterSet, InFilter, NotInFilter\n\n\nclass ProductFilterSet(FilterSet):\n    ids = InFilter(Product.id)\n    excluded_ids = NotInFilter(Product.id)\n\n\nfilter_params = {\"excluded_ids\": [1, 2, 3]}\nfilter_set = ProductFilterSet(session, select(Product))\nresult = filter_set.filter(filter_params)\n</code></pre> <p>Filter schema pattern:</p> dictpydantic <pre><code>value1 = [1, 2, 3]\nvalue2 = [\"4\", \"5\", \"6\"]\n\nfilter_params = {\"field1\": value1, \"field2\": value2}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    field1: list[int] | None\n    field2: list[str] | None\n\nvalue1 = [1, 2, 3]\nvalue2 = [\"4\", \"5\", \"6\"]\n\nfilter_params = ProductFilterSchema(field1=value1, field2=value2).dict(\n    exclude_unset=True\n)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"ids\": [1, 2, 3]}</code> <code>select * from product where id in (1, 2, 3);</code> <code>{\"excluded_ids\": [1, 2, 3]}</code> <code>select * from product where id not in (1, 2, 3);</code> <code>{\"ids\": []}</code> <code>select * from product where id IN (NULL) AND (1 != 1);</code> <p>Warning</p> <ul> <li> <p>Filtering by <code>None</code> value is not possible for sqlalchemy <code>in_</code> operator.</p> </li> <li> <p>By passing an empty list, filtering will work according to the standard sqlalchemy rules: Empty IN Expressions.</p> </li> </ul>"},{"location":"filters/#booleanfilter","title":"BooleanFilter","text":"<p><code>BooleanFilter</code> is a subclass of the <code>Filter</code> class that allows you to filter a field based on a boolean value using the <code>=</code>/<code>!=</code> SQL operators. Under the hood it is a <code>Filter</code> with special <code>operator.eq</code> and <code>operator.ne</code> lookup expressions.</p> <p>Example: <pre><code>from sqlalchemy_filterset import FilterSet, BooleanFilter\n\n\nclass ProductFilterSet(FilterSet):\n    is_active = BooleanFilter(Product.is_active)\n\n\nfilter_params = {\"is_active\": True}\nfilter_set = ProductFilterSet(session, select(Product))\nresult = filter_set.filter(filter_params)\n</code></pre></p> <p>Filter schema pattern:</p> dictpydantic <pre><code>value1 = True\nvalue2 = False\n\nfilter_params = {\"field1\": value1, \"field2\": value2}\n</code></pre> <pre><code>class ProductFilterSchema(BaseModel):\n    field1: bool | None\n    field2: bool | None\n\nvalue1 = True\nvalue2 = False\n\nfilter_params = ProductFilterSchema(field1=value1, field2=value2).dict(\n    exclude_unset=True\n)\n</code></pre> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"is_active\": True}</code> <code>select * from product where is_active is true;</code> <code>{\"is_active\": False}</code> <code>select * from product where is_active is false;</code> <code>{\"is_active\": None}</code> <code>select * from product where is_active is null;</code>"},{"location":"filters/#methodfilter","title":"MethodFilter","text":"<p><code>MethodFilter</code> allows to define a custom filtering behavior for a particular field.</p> <p>Here's an example:</p> <pre><code>from sqlalchemy.sql import Select, and_, or_\nfrom sqlalchemy_filterset import FilterSet, MethodFilter\n\n\nclass ProductFilterSet(FilterSet):\n    available = MethodFilter(method=\"filter_available\")\n\n    @staticmethod\n    def filter_available(query: Select, value: bool) -&gt; Select:\n        if value is True:\n            return query.where(\n                and_(Product.is_active.is_(True), Product.price &gt; 100)\n            )\n        elif value is False:\n            return query.where(\n                or_(Product.is_active.is_(False), Product.price &lt;= 100)\n            )\n        return query\n\n\n\nfilter_params = {\"available\": True}\nfilter_set = ProductFilterSet(session, select(Product))\nresult = filter_set.filter(filter_params)\n</code></pre> <p>Filter schema pattern is custom and depends on the <code>value</code> attribute expected in the <code>MethodFilter</code> filter method.</p> <p>Resulting sql expressions:</p> filter_params SQL expression <code>{\"available\": True}</code> <code>select * from product where is_active is true and price &gt; 100;</code> <code>{\"available\": False}</code> <code>select * from product where is_active is false or price &lt;= 100;</code> <code>{\"available\": None}</code> <code>select * from product;</code>"},{"location":"filters/#custom-filter","title":"Custom filter","text":"<p>An alternative way to add custom filter behavior is to create a separate filter. To achieve this, a <code>CustomFilter</code> must extend the base filter class and override its filter method.</p> <p>For example, the behavior of the filter method example above can be achieved as follows: <pre><code>from typing import Any\nfrom sqlalchemy.sql import Select, and_, or_\nfrom sqlalchemy_filterset import FilterSet, BaseFilter\n\n\nclass AvailableFilter(BaseFilter):\n    def filter(self, query: Select, value: Any, values: Any) -&gt; Select:\n        if value is True:\n            return query.where(\n                and_(Product.is_active.is_(True), Product.price &gt; 100)\n            )\n        elif value is False:\n            return query.where(\n                or_(Product.is_active.is_(False), Product.price &lt;= 100)\n            )\n        return query\n\n\n\nclass ProductFilterSet(FilterSet):\n    available = AvailableFilter()\n\n\nfilter_params = {\"available\": True}\nfilter_set = ProductFilterSet(session, select(Product))\nresult = filter_set.filter(filter_params)\n</code></pre></p>"},{"location":"filters/#filter-strategy","title":"Filter strategy","text":"<p>Strategy is part of a <code>Filter</code> that controls how to connect the <code>Filter</code> expression with a query. The main target of it is filtering by related models in the most optimized way.</p>"},{"location":"filters/#basestrategy","title":"BaseStrategy","text":"<p><code>BaseStrategy</code> is the simplest and default strategy. It simply connects the expression built by <code>Filter</code> to query by <code>query.where</code> method.  It's the default value of filters.</p> <pre><code># The same result\nid = Filter(Product.id)\nid = Filter(Product.id, strategy=BaseStrategy())\n</code></pre>"},{"location":"filters/#joinstrategy","title":"JoinStrategy","text":"<p>Join strategies are good for filtering by one-to-many or one-to-one relations. It joins table by given <code>onclause</code>. If a table with the same <code>onclause</code> has already been joined it will not be joined twice.</p> <ul> <li><code>model</code> - a model or table which you want to join.</li> <li><code>oncaluse</code> - an onclause expression that will be used for the join.</li> <li><code>is_outer</code> - if True, generate <code>LEFT OUTER</code> join. Default False.</li> <li><code>is_full</code> - if True, generate <code>FULL OUTER</code> join. Default False.</li> </ul>"},{"location":"filters/#usage","title":"Usage","text":"<pre><code>category_title = Filter(\n    Category.title,\n    strategy=JoinStrategy(\n        Category, onclause=Product.category_id == Category.id\n    ),\n)\n</code></pre> <p>Example of result query: <pre><code>select *\nfrom product\njoin category on category.id = product.category_id\nwhere category.title = 'test';\n</code></pre></p>"},{"location":"filters/#multijoinstrategy","title":"MultiJoinStrategy","text":"<p>Apply multiple <code>JoinStrategy</code> for filter. May used in cases of many-to-many filters.</p> <p>Warning</p> <p>Every case of many-to-many filtering is unique and requires query analysis. Do not use it <code>MultiJoinStrategy</code> blindly.</p> <ul> <li><code>*joins</code> - sequence of <code>JoinStrategy</code> you want to apply.</li> </ul>"},{"location":"filters/#usage_1","title":"Usage","text":"<pre><code>tag_title = Filter(\n    Tag.title,\n    strategy=MultiJoinStrategy(\n        JoinStrategy(TagToProduct, onclause=Product.id == TagToProduct.right_id),\n        JoinStrategy(Tag, onclause=Tag.id == TagToProduct.left_id),\n    )\n)\n</code></pre> <p>Example of result query: <pre><code>select *\nfrom product\njoin tag_to_product on product.id = tag_to_product.right_id\njoin tag on tag.id = tag_to_product.left_id\nwhere tag.title = 'test';\n</code></pre></p>"},{"location":"filters/#subqueryexistsstrategy","title":"SubqueryExistsStrategy","text":"<p>This strategy is good for many-to-one relations. It makes exists subquery with onclause and filter expression in <code>where</code>. If the query already has exists subquery with same onclause and table, it will add filter expression to the <code>where</code> clause.</p>"},{"location":"filters/#usage_2","title":"Usage","text":"<pre><code>product_title = Filter(\n    Product.title,\n    strategy=SubqueryExistsStrategy(\n        Product, onclause=Category.id == Product.category_id\n    ),\n)\n</code></pre> <p>Example of result query:</p> <pre><code>-- select all categories for which there is a product with the name 'test'\n\nselect *\nfrom category\nwhere exists(select 1\nfrom product\nwhere category.id = product.category_id\nand product.title = 'test');\n</code></pre> Efficient Data Filtering: Using the EXISTS Clause in SQL <p>The <code>exists</code> keyword is used in the above query to optimize the performance of the query by only returning the categories that have at least one product that meets the specified criteria (in this case, a product with the title of \"test\").</p> <p>The subquery within the <code>exists</code> clause only needs to return one column, in this case the constant <code>1</code>, to check whether there is at least one row that meets the criteria specified in the subquery's <code>where</code> clause. Since it only needs to check for the existence of one row, this approach is more efficient than using a traditional <code>join</code> and <code>where</code> clause to filter the data.</p> <p>Additionally, using <code>exists</code> allows you to check for the existence of related data without actually retrieving the related data, which makes it more efficient when you don't need to retrieve the related data but just check if it exist or not.</p>"},{"location":"filtersets/","title":"Filtersets","text":""},{"location":"filtersets/#overview","title":"Overview","text":"<p><code>BaseFilterSet</code> is a class that modifies a database query by adding <code>where</code> clauses to it based on specified filters. To use it, create an instance of <code>BaseFilterSet</code> class and define filters. To apply the filtering to a query, pass the query to the filter method of the <code>BaseFilterSet</code> instance.</p>"},{"location":"filtersets/#workflow","title":"Workflow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant App\n    participant Database\n    User-&gt;&gt;App: Send request with filter parameters\n    App-&gt;&gt;App: Retrieve User Filter Parameters.&lt;br&gt; Apply Parameters to FilterSet and Construct Query\n    App-&gt;&gt;Database: Execute Query\n    Database--&gt;&gt;App: Send Results\n    App--&gt;&gt;User: Display Results</code></pre> <p>Example <code>FilterSet</code>: <pre><code>from sqlalchemy_filterset import (\n    BaseFilterSet,\n    BooleanFilter,\n    Filter,\n    InFilter,\n    RangeFilter,\n)\n\n\nclass ProductFilterSet(BaseFilterSet):\n    id = Filter(Product.id)\n    ids = InFilter(Product.id)\n    title = Filter(Product.title)\n    price = RangeFilter(Product.price)\n    category = InFilter(Product.category)\n    is_active = BooleanFilter(Product.is_active)\n</code></pre></p>"},{"location":"filtersets/#filter-schema","title":"Filter schema","text":"<p>Filter schema is a dictionary that defines the parameters for filtering a database query using a <code>BaseFilterSet</code>. It has the format of <code>{filter_name: value}</code>, where <code>filter_name</code> is the name of the field in the <code>BaseFilterSet</code> and value is the value to use for filtering. However, different filters may have different formats (see the filters description).</p> <p>Using pydantic to define the filter schema is a convenient way to ensure the proper format and validation of the filter parameters.</p> <p>For example, to filter the <code>ProductFilterSet</code> by active products, a minimum price of 1000, a maximum price of 5000, use the following filter_schema:</p> dictpydantic <pre><code>filter_params = {\"price\": (1000, 5000), \"is_active\": True}\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass ProductFilterSchema(BaseModel):\n    id: int | None\n    ids: set[int] | None\n    title: str | None\n    price: tuple[Price | None, Price | None] | None\n    category: set[ProductCategory] | None\n    is_active: bool | None\n\nfilter_schema = ProductFilterSchema(price=(1000, 5000), is_active=True)\nfilter_params = filter_schema.dict(exclude_unset=True)\n</code></pre> <p>Note: Using exclude_unset=True</p> <ul> <li>When the <code>exclude_unset=True</code> parameter is used in the <code>dict()</code> method, fields that were not explicitly set when creating the model are excluded from the returned dictionary. This is useful in this example because it means that only the attributes that have been set in the <code>filter_schema</code> object are included in the <code>filter_params</code> dictionary. In this case, the <code>filter_schema</code> object only has three attributes set: <code>price</code>, <code>is_active</code>, and <code>category</code>, so when <code>exclude_unset=True</code>, only these three attributes are included in the <code>filter_params</code> dictionary, and the other attributes with <code>None</code> value (<code>id</code>, <code>ids</code>, <code>title</code>) are excluded. This way, the query only filters by the passed parameters, and the <code>None</code> parameters will not affect it.</li> </ul>"},{"location":"filtersets/#filtering","title":"Filtering","text":"<p>To apply filtering, you can pass <code>filter_params</code> to the filter method of the <code>ProductFilterSet</code>.</p> <p>For example: <pre><code>from sqlalchemy import select\n\n\nquery = select(Product)\nfilter_set = ProductFilterSet(query)\nquery = filter_set.filter_query(filter_params)\n</code></pre> The resulting sql: <pre><code>select *\nfrom product\nwhere price &gt;= 100\nand price &lt;= 500\nand is_active is true;\n</code></pre></p>"},{"location":"filtersets/#counting","title":"Counting","text":"<p>The count function of <code>FilterSet</code> is used to count the number of records in a database that match a set of filters. The result will be an integer representing the count of the number of matching records.</p> <p>For example: <pre><code>from sqlalchemy import select\n\n\nquery = select(Product)\nfilter_set = ProductFilterSet(query)\nquery = filter_set.count_query(filter_params)\n</code></pre> The resulting sql: <pre><code>select count(1)\nfrom product\nwhere price &gt;= 100\nand price &lt;= 500\nand is_active is true;\n</code></pre></p>"},{"location":"filtersets/#filtersetasyncfilterset","title":"FilterSet/AsyncFilterSet","text":"<p>There are two classes: <code>FilterSet</code> and <code>AsyncFilterSet</code>. They inherited from BaseFilterSet and have two additional methods <code>filter</code> and <code>count</code>. These methods work with the same query and session, so we can consistently call both methods tougether.</p> <p>Example - get top 10 paginated rows and total count of rows:</p> <pre><code>class ProductFilterSchema(BaseModel):\n    id: int | None\n    pagination: tuple[Price | None, Price | None] | None\n\n\nclass ProductFilterSet(AsyncFilterSet):\n    id = Filter(Product.id)\n    pagination = LimitOffsetFilter()\n\nquery = select(Product)\nfilter_params = ProductFilterSchema(pagination=(10, 0)).dict(exclude_unset=True)\nfilter_set = ProductFilterSet(session, query)  # we pass session here\nresult = await filter_set.filter(filter_params)\ncount = await filter_set.count(filter_params)\n</code></pre>"},{"location":"examples/fastapi/","title":"FastApi","text":""},{"location":"examples/fastapi/#fastapi-example","title":"FastApi Example","text":"<p>This example shows how to use <code>sqlalchemy-filterset</code> with FastAPI and SQLAlchemy.</p> <p>The source code is available on the Github.</p>"},{"location":"examples/fastapi/#application-structure","title":"Application structure","text":"<p>Application has next structure:</p> <pre><code>./\n\u251c\u2500\u2500 webapp/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 application.py\n\u2502   \u251c\u2500\u2500 endpoints.py\n\u2502   \u251c\u2500\u2500 schemas.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 filters.py\n\u2502   \u251c\u2500\u2500 queries.py\n\u2502   \u2514\u2500\u2500 tests.py\n\u251c\u2500\u2500 config.yml\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"examples/fastapi/#create-fastapi-application","title":"Create FastAPI application","text":"webapp/application.py<pre><code>from typing import Generator\n\nfrom fastapi import FastAPI\nfrom myapp.models import Base\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session, sessionmaker\n\nengine = create_engine(\"postgresql://user:password@host/database\")\nBase.metadata.create_all(bind=engine)\nSessionLocal = sessionmaker(bind=engine)\n\n\ndef get_db() -&gt; Generator[Session, None, None]:\n    try:\n        db = SessionLocal()\n        yield db\n    finally:\n        db.close()\n\n\napp = FastAPI()\n</code></pre>"},{"location":"examples/fastapi/#models","title":"Models","text":"<p>Here is an example of creating models for e-commerce application. More information about the models can be found in the official sqlalchemy documentation</p> webapp/models.py<pre><code>import enum\nimport uuid\n\nfrom sqlalchemy import Boolean, Column, Enum, ForeignKey, Numeric, String\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import declarative_base, relationship\n\nBase = declarative_base()\n\n\nclass CategoryType(enum.Enum):\n    foo = \"foo\"\n    bar = \"bar\"\n\n\nclass Category(Base):\n    __tablename__ = \"categories\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    type = Column(Enum(CategoryType), nullable=False)\n    title = Column(String)\n\n\nclass Tag(Base):\n    __tablename__ = \"tags\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    title = Column(String)\n\n\nclass TagToProduct(Base):\n    __tablename__ = \"tag_to_product\"\n    left_id = Column(\n        UUID,\n        ForeignKey(\"tag.id\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    )\n    right_id = Column(\n        UUID,\n        ForeignKey(\"product.id\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    )\n\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(String)\n    price = Column(Numeric)\n    is_active = Column(Boolean)\n    category_id = Column(\n        UUID(as_uuid=True),\n        ForeignKey(\"categories.id\"),\n        nullable=True,\n    )\n    category: Category = relationship(\"Category\", backref=\"products\")\n</code></pre>"},{"location":"examples/fastapi/#schemas","title":"Schemas","text":"<p>Add simple schemas for <code>Product</code> model.</p> webapp/schemas.py<pre><code>import uuid\n\nfrom pydantic import BaseModel\n\n\nclass ProductOut(BaseModel):\n    id: uuid.UUID\n    name: str\n    price: float\n    is_active: bool\n\n    class Config:\n        orm_mode = True\n</code></pre>"},{"location":"examples/fastapi/#filters","title":"Filters","text":"<p>Add <code>FilterSet</code> and <code>FilterSchema</code> for the <code>Product</code> model.</p> webapp/filters.py<pre><code>import uuid\n\nfrom pydantic import BaseModel\nfrom webapp.models import Category, CategoryType, Product, Tag, TagToProduct\n\nfrom sqlalchemy_filterset import (\n    Filter,\n    FilterSet,\n    InFilter,\n    JoinStrategy,\n    LimitOffsetFilter,\n    MultiJoinStrategy,\n    OrderingField,\n    OrderingFilter,\n    RangeFilter,\n    SearchFilter,\n)\n\n\nclass ProductFilterSet(FilterSet):\n    id = Filter(Product.id)\n    ids = InFilter(Product.id)\n    name = SearchFilter(Product.name)\n    price = RangeFilter(Product.price)\n    is_active = Filter(Product.is_active)\n    category_type = Filter(\n        Category.type,\n        strategy=JoinStrategy(\n            Category,\n            Product.category_id == Category.id,\n        ),\n    )\n    tag_title = Filter(\n        Tag.title,\n        strategy=MultiJoinStrategy(\n            JoinStrategy(TagToProduct, onclause=Product.id == TagToProduct.right_id),\n            JoinStrategy(Tag, onclause=Tag.id == TagToProduct.left_id),\n        ),\n    )\n    ordering = OrderingFilter(\n        name=OrderingField(Product.name),\n        price=OrderingField(Product.price),\n    )\n    limit_offset = LimitOffsetFilter()\n\n\nclass ProductFilterSchema(BaseModel):\n    id: uuid.UUID | None\n    ids: list[uuid.UUID] | None\n    name: str | None\n    price: tuple[float, float] | None\n    is_active: bool | None\n    category_type: CategoryType | None\n    tag_title: str | None\n    ordering: list[str] | None\n    limit_offset: tuple[int | None, int | None] | None\n\n    class Config:\n        orm_mode = True\n</code></pre>"},{"location":"examples/fastapi/#queries","title":"Queries","text":"<p>Add queries for api endpoints. webapp/queries.py<pre><code>import dataclasses\nimport uuid\n\nfrom fastapi import Query\nfrom myapp.models import CategoryType\n\n\n@dataclasses.dataclass\nclass ProductQuery:\n    id: uuid.UUID | None = Query(None)\n    ids: list[uuid.UUID] | None = Query(None)\n    name: str | None = Query(None)\n    price_min: int | None = Query(None)\n    price_max: int | None = Query(None)\n    is_active: bool | None = Query(None)\n    category_type: CategoryType | None = Query(None)\n    ordering: list[str] | None = Query(None)\n    limit: int | None = Query(None)\n    offset: int | None = Query(None)\n\n    @property\n    def limit_offset(self) -&gt; tuple[int | None, int | None] | None:\n        if self.limit or self.offset:\n            return self.limit, self.offset\n        return None\n\n    @property\n    def price(self) -&gt; tuple[float, float] | None:\n        if self.price_min and self.price_max:\n            return self.price_min, self.price_max\n        return None\n</code></pre></p>"},{"location":"examples/fastapi/#endpoints","title":"Endpoints","text":"<p>Add endpoints for the application.</p> webapp/endpoints.py<pre><code>from fastapi import Depends\nfrom pydantic import parse_obj_as\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom webapp.applications import app, get_db\nfrom webapp.filters import ProductFilterSchema, ProductFilterSet\nfrom webapp.models import Product\nfrom webapp.queries import ProductQuery\nfrom webapp.schemas import ProductOut\n\n\n@app.get(\"/products/\")\ndef list_products(\n    filters: ProductQuery = Depends(),\n    db: Session = Depends(get_db),\n) -&gt; list[ProductOut]:\n    filter_set = ProductFilterSet(db, select(Product))\n    filter_params = parse_obj_as(ProductFilterSchema, filters)\n    filtered_products = filter_set.filter(filter_params.dict(exclude_none=True))\n    return parse_obj_as(list[ProductOut], filtered_products)\n</code></pre>"},{"location":"examples/fastapi/#usage","title":"Usage","text":"<p>Run application with <code>uvicorn</code>.</p> <p><pre><code>uvicorn webapp.application:app --reload\n</code></pre> Go to http://127.0.0.1:8000/docs</p> <p></p>"},{"location":"examples/fastapi/#conclusion","title":"Conclusion","text":"<p>In conclusion, this example demonstrates how to use the <code>sqlalchemy-filterset</code> library with <code>FastAPI</code> and <code>SQLAlchemy</code>. It shows the structure of an application that uses this library, including the creation of a <code>FastAPI</code> application, models, schemas, and filters. The example also includes the usage of various filters such as <code>InFilter</code>, <code>RangeFilter</code>, and <code>OrderingFilter</code> to filter data from the database. The example also demonstrates the use of <code>JoinStrategy</code> to filter data from related models.</p>"}]}